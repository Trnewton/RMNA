'''

'''


import numpy as np
import networkx as nx

from shapely.geometry import LineString
from shapely.geometry import MultiLineString

import matplotlib.pyplot as plt



################################################ Physical Newtork Object ################################################

class Physical_NWN:
    '''
        Object to represent a physical nanowire network (NNW), and its associated operations.

        Stores information about the location and orientation of each nanowire in the network, as well as the presence of
        electrical plates for supplying or extracting current or voltage from the network. 


        Attributes
        ----------
        wires : shapely.geometry MultiLineString
            Shapely object representing the nanowires of the newtork.

        plates : shapely.geometry MultiLineString
            Shapely object representing the plates of the newtork.

        intercepts : list of tuples
            List of the intercepts currently calculated for the network. Each element of the list is of the form:
                ((x, y), lable1, label2)
            where the tuple (x, y) represents the location of the intersection within the plane, lable1 is the label 
            for the first wire/plate involed in the intersection and lable2 is the label for the second. Each lable
            is of the form [W,P]\d+, that is a character indicating whether the wire is a plate (P) or a wire (W) 
            and a digit repesenting which plate/wire it is.

        new_wire_flag : bool
            Flag to determine if new wires/plates have been added since the last list of intercepts was calculated 

        removed_wires_flag : bool
            Flag to determine if wires/plates have been removed since the last list of intercepts was calculated


        Methods
        -------
        __inti__
            Initiates attributes

        create_nwn_end(seed=None)
            Uses the endpoint method to create random nanowire network.
        
        create_nwn_mid(seed=None)
            Uses the midpoint method to create random nanowire network.

        calc_intercepts
            Calculates the intercepts within the netwrok.
        
        draw
            Displays the network.

    '''

    def __init__(self):
        '''

        '''

        self.plates = MultiLineString()
        self.wires = MultiLineString()
        self.new_plates = MultiLineString()
        self.new_wires = MultiLineString()

        self.intercepts = []

        self.new_wire_flag = False
        self.removed_wires_flag = False


    def create_nwn_end(self, N, X, Y, l0, seed=None):
        '''
            Generates a list of endpoints for a random network of wires using the "end-point" method.

            Each random nanowire is generated by first randomly generating an (x, y) coordinate for the first
            end point, then an random angle between 0 and 2pi is generated to calculate the second endpoint of the wire.

            Parameters
            ----------
            N : int
                The number of nanowires to be genreated
            X : positive float
                The maximum x value the first nanowire endpoint might have
            Y : positive float
                The maximum y value the first nanowire endpoint might have
            l0 : positive float
                The length of the nanowires
            seed : float
                The seed value to be used by the numpy random number generator

            Returns
            -------
            wires : Shapely MultiLinString
                Shapely object representing the nanowires
        '''

        if seed is not None:
            np.random.seed(seed)


        l = l0 #Make random
        pos1 = np.concatenate((np.random.rand(N,1)*X, np.random.rand(N,1)*Y), axis=1)
        theta = np.random.rand(N)*2*np.pi
        pos2 = pos1 + (np.array([np.cos(theta), np.sin(theta)])*l).T

        self.new_wires =  MultiLineString(list(zip(pos1, pos2)))
        self.new_wire_flag = True

        return self.wires


    def create_nwn_mid(self, N, X, Y, l0, seed=None):
        '''
            Generates a list of endpoints for a random network of wires using the "mid-point" method

            Each random nanowire is generated by first randomly generating an (x, y) coordinate for the mid-way
            point, then an random angle between 0 and 2pi is generated to calculate the two endpoints of the wire.

            Parameters
            ----------
            N : int
                The number of nanowires to be genreated
            X : positive float
                The maximum x value the middle of the nanowire
            Y : positive float
                The maximum y value the middle of the nanowire
            l0 : positive float
                The length of the nanowires
            seed : float
                The seed value to be used by the numpy random number generator

            Returns
            -------
            wires : Shapely MultiLinString
                Shapely object representing the nanowires
        '''
        
        if seed is not None:
            np.random.seed(seed)

        l = l0#Make random
        center = np.array([np.random.rand(N)*X, np.random.rand(N)*Y]).T
        theta = np.random.rand(N)*2*np.pi
        dp = (np.array([np.cos(theta), np.sin(theta)])*l/2).T
        pos1 = center + dp
        pos2 = center - dp

        self.new_wires =  MultiLineString(list(zip(pos1, pos2)))
        self.new_wire_flag = True
        return self.wires


    def add_elements(self, new_elements):
        '''
            Creates wires/plates 
            plates: [("[P,W]",(x1, y1), (x2, y2)), ... ]
        '''

        self.new_wires = True

        if new_elements is not None:
            for element in new_elements:
                if element[0] == 'W':
                    self.new_wires.append(LineString(element[1:3]))
                elif element[0] == 'P':
                    self.new_plates.append(LineString(element[1:3]))


    def calc_intercepts(self):
        '''
            Calculates the intercepts for the nanowire network. 
            
            Each intercept is stored in the "intercepts" attribute with the form ((x, y), Label1, Label2) where "(x, y)" is the 
            position of the intercept in the plane, "Label1" is the label of the first plate/wire involved in the interception
            and "Label2" is the second.

            Returns
            -------
            intercepts : List of tuples
                Returns the list of tuples describing each intercept as explained above
        '''

        # Find intercepts between wires by iterating over wires in new_wires list
        for n, w1 in enumerate(self.new_wires):
            # Check 'w1' against wires in wire list
            for m, w2 in enumerate(self.wires):
                # If they cross find the (x, y) cooridinates and get labels then add to intercepts list
                if w1.crosses(w2):
                    p = w1.intersection(w2)
                    # The label of 'w1' is the number of wires already checked
                    self.intercepts.append(((p.x, p.y), 'W'+str(len(self.wires)), 'W'+str(m)))

            # Once 'w1' is checked against all wires in wire list, add it to wire list so new 'w1' will be checked agaisnt old 'w1'
            self.wires.append(w1)

        # Find intercepts between wires and plates by iterating over new_plates list
        for n, plate in enumerate(self.new_plates):
            # Check 'plate' against all wires in wire list
            for m, wire in enumerate(self.wires):
                # If intersection find (x, y) coordinates and provide labels for intercepts list
                if wire.crosses(plate):
                    p = wire.intersection(plate)
                    # The label of the plate is the length of the plates already in plates list
                    self.intercepts.append(((p.x, p.y),'P'+str(len(self.plates)), 'W'+str(m)))
            self.plates.append(plate)

        # Assuming plates do not short we do not need check if they intersect

        # Reset new wire/plate lists
        self.new_wires = []
        self.new_plates = []
        self.new_wire_flag = False

        return self.intercepts


    def draw(self):
        '''
        Draws the nanowire network using the matplotlib.pyplot package. 
        
        Wires which have had their intercepts calculated
        are coloured cyan, while wires that have not yet had intecepts calculated are coloured red, both wire types are 
        also labeled with the order they were added. Plates are coloured yellow if their intercepts have been calculated
        and blue if they have not, both are also labeled with the corresponding order in which they were added. When they 
        have been calculated intercepts are plotted as black "*". 
        '''

        __, ax = plt.subplots()

        # Plot wires with labels
        for n, wire in enumerate(self.wires):
            x, y = wire.xy
            ax.plot(x, y, color='c')
            ax.plot(x[0], y[0], 'o', ms=4, color='b')
            ax.plot(x[1], y[1], 'o', ms=4, color='g')
            ax.text((x[0] + x[1])/2, (y[0] + y[1])/2, 'W' + str(n))

        # Plot new wires that have not had intercepts calculated yet
        for n, wire in enumerate(self.new_wires):
            x, y = wire.xy
            ax.plot(x, y, color='r')
            ax.plot(x[0], y[0], 'o', ms=4, color='b')
            ax.plot(x[1], y[1], 'o', ms=4, color='g')
            ax.text((x[0] + x[1])/2, (y[0] + y[1])/2, 'W' + str(len(self.wires)+n))

        # Plot plates with labels
        for n, plate in enumerate(self.plates):
            x, y = plate.xy
            ax.plot(x, y, color='y')
            ax.text(x[1], y[1], 'P' + str(n))

        # Plot new plates that have not had intercepts calculated yet
        for n, plate in enumerate(self.plates):
            x, y = plate.xy
            ax.plot(x, y, color='b')
            ax.text(x[1], y[1], 'P' + str(len(self.plates)+n))

        # Plot intercepts
        if self.intercepts is not None:
            for intercept in self.intercepts:
                x, y = intercept[0]
                ax.plot(x, y, '*' , ms=6, color='k')     

        plt.show()


################################################ Graphical Object ################################################

class Graph_NWN:
    '''

    '''

    def __init__(self):
        '''

        '''

        self.grap_representation = ''
        self.graph = None
        self.memristors = {}
        self.resistors = {}
        self.plates = {}


    def jda_from_network(self, network):
        '''
            Creates graph of nanowire network using the Junction Dominated Assumption (JDA), returning a networkx 
            graph object with nodes either labelled with a 'P' to indicate a plate or a 'W' to indicate a 
            wire followed by the order in which the plate/wire was labelled. 

            Parameters
            ----------
            network : physical_nwn
                Physical representation of the nanowire network

            Returns
            -------
            graph : networkx graph
                Graphical representation of the nanowire network using the JDA
        '''
        
        self.graph_representation = 'Junction Dominated Assumption'
        self.graph = nx.Graph()

        # Check to make sure the network has intersections calculated
        if network.intercepts is None:
            print('ERROR: No intersections in network object, use network.calc_intercepts() first.')
            return None
        elif network.new_wire_flag == True:
            print('WARNING: Netork has had new elements since last time intercepts were calculated')

        # Use precalculated intercepts to create graph
        for __, wire1, wire2 in network.intercepts:
            # Create new memristor object and add it to the graph and the memristor list
            obj = Memristor(wire1+wire2)
            
            if 'P' in wire1:
                plate = self.plates.setdefault(wire1, Plate(wire1))
                self.graph.add_edge(plate, wire2, circuit_element=obj)
            elif 'P' in wire2:
                plate = self.plates.setdefault(wire2, Plate(wire2))
                self.graph.add_edge(wire1, plate, circuit_element=obj)
            else:
                self.graph.add_edge(wire1, wire2, circuit_element=obj)

            self.memristors[wire1 + wire2] = obj

        return self.graph


    def mnr_from_network(self, network):
        '''
            Creates graph of nanowire network using the Multi-Nodular Representation (MNR), returning a networkx 
            graph object with nodes either labelled with a 'P' to indicate a plate or a 'W' to indicate a 
            wire followed by the order in which the plate/wire was labelled. 

            Parameters
            ----------
            network : physical_nwn
                Physical representation of the nanowire network

            Returns
            -------
            graph : networkx graph
                Graphical representation of the nanowire network using the MNR
        '''

        import heapq
         
        self.graph_representation = 'Multi-Nodal Representation'
        self.graph = nx.Graph()

        # Check to make sure the network has intersections calculated
        if network.intercepts is None:
            print('ERROR: No intersections in network object, use network.calc_intercepts() first.')
            return None
        elif network.new_wire_flag == True:
            print('WARNING: Netork has new elements whos intercepts have not been calculated')

        # Create a dictionary to store heaps for each wire
        # The heap will automatically order the wires intersections as we add them so we can later get the correct
        # resistor lengths
        wire_dict = {}

        # Iterate over intersections and their wires, adding memristor edges
        for pos, wire1, wire2 in network.intercepts:
            # Create/add to head for wire1
            heap1 = wire_dict.setdefault(wire1, [])

            # If the wire is not a plate we add a label so we know which intersections it is and where
            if 'P' not in wire1:
                int1 = (pos, wire1 + 'J' + str(len(heap1)) )
            # If the wire is a plate we do not care about spacing between intersections so we just store the pos and plate label
            else:
                int1 = (pos, wire1)

            # Push the new intersection to its heap
            heapq.heappush(heap1, int1)

            # Create complimentary intersection and push it to its respective heap
            heap2 = wire_dict.setdefault(wire2, [])
            int2 = (pos, wire2 + 'J' + str(len(heap2)) )
            heapq.heappush(heap2, int2)

            # Add new memristor object to graph and memristor list
            obj = circuit_element('Memristor')
            self.graph.add_edge(int1[1], int2[1], circuit_element=obj) 
            self.memristors[int1[1] + int2[1]] = circuit_element


        # Iterate over wire dictionary and detemine resistor lengths and add to graph
        for wire in wire_dict:
            # If the wire is not a plate
            if 'P' not in wire:
                # From our dictionary collect the wires heap 
                heap = wire_dict.get(wire, [])

                # If the heap is not empty pop the head
                if heap:
                    int1 = heapq.heappop(heap)
                # While we still have an element in the heap pop the head and calc the distance between the last node
                # and the new one
                while heap:
                    # Pops new head and shifts 
                    int2 = int1
                    int1 = heapq.heappop(heap)

                    # Calculates distance and adds to the graph
                    int_dist = np.sqrt( (int1[0][0] - int2[0][0])**2 + (int1[0][1] - int2[0][1])**2 )

                    # Create resistor object
                    obj = circuit_element('Resistor', length=int_dist)

                    # Add resistor object to graph and resistor list
                    self.graph.add_edge(int1[1], int2[1], circuit_element=obj)
                    self.resistors[int1[1] + int2[1]] = obj

        return self.graph


################################################ Electrical Newtork Object ################################################ 

class Electrical_NWN:
    '''

    '''

    def __init__(self):
        '''

        '''

        self.A_map = {}
        self.A = None
        self.x = None
        self.z = None
        self.memristors = None
        self.resistors = None

    def create_mna(self, graph_obj):
        '''
            Uses graph representation of nanowire network to generate the A, x, and z matrices used in 
            modified nodal analysis of an electric network. The x matrix is returned as a dictionary where
            the key is the name of each node/plate and the value is which index of A and z it corresponds to.
        '''

        if graph_obj.graph is None:
            print('Error: No graph representation, use graph_jda or graph_mnr first.')
            return None

        A_map = {}
        z_map = {}
        x = {}

        for v in graph_obj.graph:
            n = x.setdefault(v, len(x))

            # Construct resistance (G) matrix
            for w in graph_obj.graph.adj[v]:
                m = x.setdefault(w, len(x))
                circuit_element = graph_obj.graph.edges[v, w]['circuit_element']
                indxs = A_map.setdefault(circuit_element, [])
                indxs.append((n, m, -1))
                indxs.append((n, n, 1))

            # Construct voltage/current (C/B) of matrix
            if 'P' in v:
                if self.plat_vals[int(v[1])][0] == 'V':
                    m = x.setdefault('i' + v, len(x))
                    A[m][n] = 1
                    A[n][m] = 1
                    z[m] = self.plat_vals[int(v[1])][1]
                elif self.plat_vals[int(v[1])][0] == 'I':
                        z[n] = self.plat_vals[int(v[1])][1]

        ##########################################################################################################s
        A = np.zeros((len(graph_obj.graph) + len(graph_obj.plates), len(graph_obj.graph) + len(graph_obj.plates)))
        z = np.zeros(len(graph_obj.graph) + len(graph_obj.plates))

        for v in graph_obj.graph:
            n = x.setdefault(v, len(x))

            # Construct resistance (G) matrix
            total = 0
            for w in graph_obj.graph.adj[v]:
                m = x.setdefault(w, len(x))
                total += 1 / graph_obj.graph.edges[v, w]['weight']
                A[n][m] = - 1 / graph_obj.graph.edges[v, w]['weight']
            A[n][n] = total

            # Construct voltage/current (C/B) of matrix
            if 'P' in v:
                if self.plat_vals[int(v[1])][0] == 'V':
                    m = x.setdefault('i' + v, len(x))
                    A[m][n] = 1
                    A[n][m] = 1
                    z[m] = self.plat_vals[int(v[1])][1]
                elif self.plat_vals[int(v[1])][0] == 'I':
                        z[n] = self.plat_vals[int(v[1])][1]

        # Remove zero rows and columns
        A = A[~(A==0).all(1)]
        A = A[:, ~(A==0).all(0)]
        z = z[:len(A)]

        self.A = A
        self.x = x
        self.z = z

        return A, x, z

    def update_mna(self):
        '''

        '''

        pass
    
################################################ Circuit Element Objects ################################################

class Circuit_Element:
    '''
    Class of objects to store information about circuit elements 
    '''

    def ___init__(self, label):
        '''
        '''

        self.label = label
    
class Plate(Circuit_Element):
    '''

    '''

    def ___init__(self, label, cur_or_volt=None, plate_val=None):
        '''
        '''

        super().__init__(self, label)
        self.cur_or_volt = cur_or_volt
        self.plate_val = plate_val

class Resistor(Circuit_Element):
    '''
    '''

    def ___init__(self, label, length, resitive_density):
        '''
        '''

        super().__init__(self, label)
        self.length = length
        self.resitive_density = resitive_density

    def resistance(self):
        '''
        '''

        return self.length * self.resitive_density

class Memristor(Circuit_Element):
    '''
    
    '''
    
    def ___init__(self, label, w_0, w, R_on, R_off, u_v):
        '''
        '''

        super().__init__(self, label)
        self.w_0 = w_0
        self.w = w
        self.R_on = R_on
        self.R_off = R_off
        self.u_v = u_V

    def time_step(self, I, dt):
        '''
        '''

        w_next = heuns_step(filament_change_1, I, self.w, dt, self.u_v, self.w_0, self.R_on)
        if w_next > self.w_0:
            w_next = self.w_0
        elif w_next < 0:
            w_next = 0
        self.w = w_next

    def resistnace(self):
        '''
        '''

        return self.R_on * (self.w / self.w_0) + self.R_off * ( 1 - self.w / self.w_0)


################################################ Auxillary Functions #################################################


def filament_change_1(I, w, u, w_0, R_on):
    '''
        Basic model for computing change in filament length in nanowire junction

        Parameters
        ----------
        I : float
            current current
        w : float 
            current filament length
        u : float
            ionic mobility
        w_0 : float
            junction seperation
        R_on : float
            on resistance

        Returns
        -------
        dwdt : float
            rate of change in filament length 
    '''

    dwdt = u * R_on * I / w_0
    
    return dwdt

def filament_change_2(I, w, u, w_0, R_on):
    '''
        Basic model for computing change in filament length in nanowire junction

        Parameters
        ----------
        I : float
            current current
        w : float 
            current filament length
        u : float
            ionic mobility
        w_0 : float
            junction seperation
        R_o : float
            on resistance

        Returns
        -------
        dwdt : float
            rate of change in filament length 
    '''

    omega = (w * (w_0 - w)) / w_0 * w_0

    dxdt = u * R_on * I * omega / (w_0*w_0)
    return dxdt

def heuns_step(func, x_0, y_0, h, *args):
    '''
    
    '''
    
    k_1 = func(x_0, y_0, *args)
    k_2 = func(x_0 + h, y_0 + h*k_1, *args)
    
    y_1 = y_0 + (h/2)*(k_1 + k_1)
    
    return y_1

def euler_step(func, x_0, y_0, h, *args): 
    '''
    
    '''
    
    y_1 = y_0 + h*func(x_0, y_0, *args)
    
    return y_1